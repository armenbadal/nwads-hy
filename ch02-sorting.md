
# 2 Կարգավորում

## 2.1 Ներածություն

Այս գլխի առաջնային նպատակն է՝ բերել նախորդ գլխում ներմուծված տվյալների կառուցվածքների օգտագործումը ցուցադրող օրինակների հարուստ բազմություն, ինչպես նաև ցույց տալ, որ մշակվող տվյալների կառուցվածքի ընտրությունը իր խոր հետքն է թողնում խնդրի լուծման վրա։ Կարգավորման խնդիրը հետաքրքիր է նաև նրանով, որ կարելի է ցույց տալ՝ ինչպես կարող է միևնույն խնդիրը լուծվել շատ տարբեր ալգորիթմներով, և դրանցից ամեն մեկն ունի իր առավելություններն ու թերությունները, որոնք պետք է ծանրութեթև անել կոնկրետ կիրառության համատեքստում։

Կարգավորում ասելով սովորաբար հասկացվում է օբյեկտների տրված բազմությունը ըստ որևէ կարգի վերադասավորելու գործողությունը։ Կարգավորման նպատակը կարգավորված բազմության մեջ տարրի հետագա որոնման հեշտացումն է։ Որպես այդպիսին այն համարյա համապիտանի, ֆունդամենտալ գործողություն է։ Օբյեկտները կարգավորված են հեռախոսայն գրքերում, հարկային եկամուտների ֆայլերում, բովանդակության ցանկերում, գրադարաններում, բառարաններում, պահեստներում, և համարյա ամենուր, որտեղ պետք է որոնել պահվող օբյեկտները։ Նույնիսկ փոքր երեխաներին են սովորեցնում իրենց իրերը «կարգին» պահել, և նրանք շատ ավելի վաղ են ծանոթանում կարգավորման որոշ տեսակների, քան ինչ֊որ բան կսովորեն թվաբանությունից։??

Հետևաբար, կարգավորումը անհրաժեշտ և կարևոր գործողություն է, հատկապես տվյալները մշակելու համար։ Է՞լ ինչը կարող է ավելի հեշտ կարգավորվել, քան տվյալները։ Այնուամենայնիվ, կարդավորման նկատմամբ մեր առաջնային հետաքրքրություն հիմնված է այն բանին, որ ալգորիթմները կազմելիս շփվում ենք բազմաթիվ հիմնարար գաղափարների հետ։ Շատ չեն այն հնարքները, որոնք չեն հանդիպում կարգավորման ալգորիթմների հետ կապված խնդիրներում։ Մասնավորապես, կարգավորումը դա ալգորիթմների բազմազանության ցուցադրման իդեալական օբյեկտ է։ Բոլոր այդ ալգորիթմները ծառայում են նույն նպատակին, դրանցից որոշները ինչ-որ իմաստով արդյունավետ են, և դրանցից շատերը առավելություններ ունեն մյուսների նկատմամբ։ Կարգավորումը նաև իդեալական օբյեկտ է՝ ցույց տալու ալգորիթմների արդյունավետության վերլուծության կարևորությունը։ Շատ հարմար է նաև կարգավորման օրինակով ցույց տալ, թե ինչպես կարելի է արտադրողականության մեջ զգալիորեն շահել՝ մշակելով ավելի բարդ ալգորիթմներ, թեև ձեռքի տակ արդեն ունենալով արդեն ակնհայտ մեթոդներ։ ??

Ալգորիթմի ընտրությունը կախված է մշակվող տվյալների առանձնահատկություններից՝ սա համարյա օրենք է, սակայն կարդավորման դեպքում այդ կախվածությունն այնքան խորն է, որ կարգավորման մեթոդները բաժանվում են երկու դասի՝ _զանգվածների կարգավորում_ և _(հաջորդական) ֆայլերի կարգավորում_։ Հաճակ այս երկու դասերն անվանվում են _ներքին_ և _արտաքին_ կարգավորում, քանի որ զանգվածները պահվում են համակարգչի արագագործ, կամայական-դիմման «ներքին» հիշասարքում, իսկ ֆայլերը պահվում են ավելի դանդաղագործ, բայց ավելի տարողունակ «արտաքին» հիշասարքերում՝ կառուցված մեխանիկական շարժվող մասերով (սկավառակ, ժապավեն)։ ?? Այս բաժանման կարևորությունն ակնհայտ է համարակալված խաղաքարտերի կարգավորման օրինակում։ Խաղաքարտերը զանգվածի տեսքով կազմակերպելը համապատասխանում է դրանք կարդավորողի դիմաց այնպես դասավորելուն, որ դրանցից ամեն մեկը տեսանելի է ուղղակիորեն մատչելի (նկ․ 2.1)։ ?? Իսկ եթե խաղաքարտերը կազմակերպված են որպես ֆայլ, ապա դա նշանակում է, որ մատչելի է միայն ամեն մի դարսի վերին խաղաքարտը (նկ․ 2.2)։ ?? Ակնհայտ է, այսպիսի սահմանափակումներն էական ազեցություններ են թողնելու ընտրվելիք կարգավորման մեթոդի վրա, սակայն դա անխուսափելի է, քանի որ կարգավորվող խաղաքարտերի քանակը կարող է մեծ լինել սեղանին տեղավորելու համար։ ??

Մինչ առաջ անցնելը, որոշ սահմանումներ ու հասկացություններ ներմուծենք, որոնք պետք է օգտագործվեն այս գլխի շարադրանքում։ Եթե տրված են `n` տարրեր․ ??

a0, a1, ... , an-1

ապա կարգավորել, նշանակում է այդ տարրերը դասավորել ??

ak0, ak1, ... , ak[n-1]

զանգվածում այնպես, որ տրված `f` կարգավորող ֆունկցիայի համար տեղի ունեն հետևյալ անհավասարությունները․ ??

f(ak0) ≤ f(ak1) ≤ ... ≤ f(ak[n-1])

Սովորաբար կարգավորող ֆունկցիան ոչ թե հաշվարկվում է ինչ-որ հատուկ օրանքով, այլ պահվում է որպես յուրաքանչյուր տարիի բացահայտ բաղադրիչ (դաշտ)։ Դրա արժեքը կոչվում է տարրի _բանալի_ (key)։ Հետևաբար շատ հարմար է տարրը ներկայացնել որպես _գրառում_ (record), և այն կարող է սահմանված լինել, օրինակ, հետևյալ կերպ․ ??

````oberon
TYPE Item = RECORD key: INTEGER;
            (*  այլ բաղադրիչների սահմանում *)
            END
````

«Այլ բաղադրիչները» ներկայացոնում են հավաքածու տարրերի էական տվյալները, իսկ բանալին ծառայում է պարզապես տարրի նույնականացման համար։ Կարգավորման ալգորիթմների մասին խոսելիս միակ նշանակալի դերը կատարելու է բանալին, և նույնիսկ կարիք էլ չկա սահմանելու մյուս բաղադրիչները։ Հետագա քննարկումներում անտեսելու ենք տարրին համադրված այլ տվյալները, և ընդունելու ենք, որ `Item` տիպը սահմանված է որպես `INTEGER`։ Բանալու տիպի ասյ ընտրությունը ինչ֊որ իմաստով կամայական է։ Նույն հաջողությամբ կարող է օգտագործվել ցանկացած տիպ, որի համար սահմանված է ընդհանուր կարգի հարաբերություն։

Կարգավորման մեթոդը կոչվում է _կայուն_ (stable), եթե կարգավորման ընթացքում անփոփոխ է մնում հավասար բանալիներ ունեցող տարրերի հարաբերական դասավորությունը։ Կարգավորման կայունությունը հաճախ ցանկալի է այն դեպքերում, երբ տարրերն արդեն դասավորված (տեսակավորված) են ըստ ինչ֊որ երկրորդական բանալու, որը չի ազդում առաջնային բանալու վրա։ ?? 

Այս գլուխը պետք չէ դիտարկել որպես կարգավորման մեթոդների սպառիչ ուսումնասիրություն։ Հակառակը, մանրամասնորեն քննարկվում են միայն մի քանի առանձին ընտրված, յուրահատուկ մեթոդներ։ Կարգավորման մանրակրկիտ վերլուծությունների համար հետաքրքրված ընթերցողին խորհուրդ ենք տալիս ընթերցել Դ․ Կնուտի հրաշալի ու համապարփակ ուսումնասիրությանը [2-7] (տես նաև [2-10])։


## 2.2 Զանգվածների կարգավորում

Զանգվածների կարգավորման մեթոդների ներկայացվող հիմնական պահանջը մատչելի հիշողության խնայողական օգտագործումն է։ Սա ենթադրում է, որ տարրերը կարգավորվածության բերելու տեղափոխությունները պետք է կատարվեն _նույն տեղում_ (in situ), այսինքն՝ `a` զանգվածից `b` նպատակային զանգվածը տարրերը տեղափոխող մեթոդները ներկայացնում են նվազագույն հետաքրքրություն։ Բազմաթիվ հնարավոր լուծումների մեջ մեզ հարկավոր եղածի ընտրությունը սահմանափակելով հիշողության խնայողության պահանջով՝ մեթոդները նախ կդասակարգենք ըստ իրեն խնայողականության, այսինքն՝ ըստ աշխատելու ժամանակի։ ?? Արդյունավետության լավ չափանիշներ կարող են ծառայել բանալիների համեմատման _C_ թիվը և տարրերի տեղափոխությունների _M_ թիվը։ Այս թվերը կարգավորվող տարրերի `n` քանակից կախված ֆունկցիաներ են։ Չնայած որ կարգավորման լավ մեթոդները պահանջում են մոտավորապես _n*log n_ համեմատություններ, մենք նախ կքննարկենք մի քանի պարզ ու ակնհայտ մեթոդներ, դրանց անվանում են նաև _ուղիղ_ մեթոդներ, որոնցում պահանջվում են բանալիների մոտ _n^2_ համեմատություններ։ Երեք կարևոր պատճառներ կան, որոնք ստիպում են այս մեթոդներն ուսումնասիրել ավելի արագ մեթոդներից առաջ։

1. Ուղիղ մեթոդները հատկապես հարմար են կարգավորումների մեծամասնության հիմնական սկզբունքների բնութագրական գծերը բացատրելու համար։
2. Այդ մեթոդների ծրագրերը հեշտ հասկանալի և կարճ են։ Հիշեցնենք, որ ծրագրերը նույնպես հիշողություն են զբաղեցնում։
3. Բարդ մեթոդները պահանջում են ոչ մեծ քանակի գործողություններ, որոնցից ամեն մեկը նույնպես բավականին բարդ է, և այդ պատճառով էլ բավականաչափ փոքր `n`֊երի համար պարզվում է, որ ուղիղ մեթոդները կարող են ավելի արագ լինել, թեև մեծ `n`֊երի համար չարժե ուղիղ մեթոդ օգտագործել։ ??

Տարրերը _նույն տեղում_ կարգավորող մեթոդները կարելի է բաժանել երեք սկզբունքային դասերի՝ according to their underlying method. ??

* Տեղադրմամբ կարգավորում (sorting by insertion), ??
* Ընտրությամբ կարգավորում (sorting by selection), ??
* Տեղափոխմամբ կարգավորում (sorting by exchange)։ ??

Այժմ կուսումնասիրենք և կհամեմատենք այս երեք սկզբունքները։ Բոլոր պրոցեդուրաներն աշխատում են `a` գլոբալ փոփոխականի հետ, որի տարրերը պետք է կարգավորվեն _նույն տեղում_՝ չպահանջելով լրացուցիչ ժամանակավոր հիշողություն։ `a` փոփոխականի տարրերը հենց բանալիներն են։ Գործողությունները պարզեցնելու համար պարզապես անտեսում ենք `Item` գրառում տիպով ներկայացված մյուս տվյալները։ Այդ գլխում մշակվող բոլոր ալգորիթմների համար կենթադրենք, որ հայտարարված է `a` զանգվածը, և `n` հաստատունը՝ `a`֊ի տարրերի թիվը։

````oberon
TYPE Item = INTEGER;
VAR a: ARRAY n OF Item
````


### 2.2.1 Ուղղակի տեղադրմամբ կարգավորում

Այս մեթոդը լայնորեն օգտագործվում է թղթախաղի ժամանակ։ Տարրերը (խաղաքարտերը) պայմանականորեն բաժանվում են արդեն կարգավորված `a0` ... `ai-1` և սկզբնական `ai` ... `an-1` հաջորդականությունների։ Ամեն մի քայլում, սկսելով `i = 1` և `i`-ն ավելացնելով մեկով, սկզբնական հաջորդականությունից ընտրվում է `i`-րդ տարրը և տեղադրվում է կարգավորված հաջորդականության մեջ՝ ճիշտ իր տեղում (ըստ կարգի)։ ?? Տեղադրմամբ կարգավորման պրոցեսը ցուցադրված է ութ պատահական վերցրած թվերի օրինակով (տես աղյուսակ 2.1)։

````
Initial keys 44 55 12 42 94 18 06 67
i=1 44 55 12 42 94 18 06 67
i=2 12 44 55 42 94 18 06 67
i=3 12 42 44 55 94 18 06 67
i=4 12 42 44 55 94 18 06 67
i=5 12 18 42 44 55 94 06 67
i=6 06 12 18 42 44 55 94 67
i=7 06 12 18 42 44 55 67 94

Աղյուսակ 2.1։ Տեղադրմամբ կարգավորման օրինակ։
````

Տեղադրմամբ կարգավորման ալգորիթմը հետևյալն է․

````
FOR i := 1 TO n-1 DO
    x := a[i];
    տեղադրել x-ը a0 ... ai-1 հաջորդականության մեջ, ճիշտ տեղում
END
````

Տեղադրվող տարրի ճիշտ տեղը որոնելիս հարմար հերթագայել համեմատություններն ու տեղափոխությունները, այսինքն թույլ տալ `x`-ին «թափանցել» դեպի ներս՝ այն համեմատելով հաջորդ `aj` տարրի հետ, իսկ հետո տեղադրել `x`-ը իր տեղում, կամ `aj` տարրը տեղաշարժել դեպի աջ ու շարունակել որոնումը ձախ ուղղությամբ։ ??? Նկատում ենք, որ տեղաշարժման պրոցեսը դադարեցնելու համար հնարավոր են երկու տարբեր պայմաններ․

1. Պարզվել է, որ `aj` տարրի բանալին ավերլի փոքր է քան `x`-ինը։
2. Հասել ենք արդեն կարգավորված հաջորդականության ձախ եզրին։

````oberon
PROCEDURE StraightInsertion;
    VAR i, j: INTEGER; x: Item;
BEGIN
    FOR i := 1 TO n-1 DO
        x := a[i]; j := i;
        WHILE (j > 0) & (x < a[j-1]) DO
            a[j] := a[j-1]; DEC(j)
        END;
        a[j] := x
    END
END StraightInsertion
````

